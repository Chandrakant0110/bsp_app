# -*- coding: utf-8 -*-
"""BSP_Band_Notebook.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1F-VlV_xk5hkNFjBA2gtkawZIyasCbCC6
"""

import pandas as pd
import numpy as np

# Load the dataset
file_path = '/content/drive/MyDrive/BSP_Project_7th_Sem/Model/Band_DWN_S_76.xlsx'
df = pd.read_excel(file_path)
df = pd.read_excel('your_file.xlsx')

# List all unique data in a specific column (e.g., 'ColumnName')
unique_data = df['ColumnName'].unique()

# Check if all jobs have the same document number
if df['Document No'].nunique() != 1:
    raise ValueError("Not all jobs have the same document number.")

# Convert date and time columns to datetime objects
# Convert StartTime and FinishTime to string before concatenation
df['start_datetime'] = pd.to_datetime(df['StartDate'] + ' ' + df['StartTime'].astype(str), format='%d.%m.%Y %H:%M:%S')
df['finish_datetime'] = pd.to_datetime(df['FinishDate'] + ' ' + df['FinishTime'].astype(str), format='%d.%m.%Y %H:%M:%S')

# Calculate the time taken for each job
df['time_taken'] = (df['finish_datetime'] - df['start_datetime']).dt.total_seconds() / 3600.0  # time in hours

# Display the first few rows to check the data
print(df.head())

# Calculate mean time taken for each operation
operation_mean_time = df.groupby('Operation_Text')['time_taken'].mean().reset_index().rename(columns={'time_taken': 'mean_time_taken_operation'})

# Calculate mean time taken on each machine
machine_mean_time = df.groupby('M/c_Description')['time_taken'].mean().reset_index().rename(columns={'time_taken': 'mean_time_taken_machine'})

# Merge mean times back to the original dataframe
# The following two lines were previously commented out, causing the error
df = df.merge(operation_mean_time, on='Operation_Text', how='left')
df = df.merge(machine_mean_time, on='M/c_Description', how='left')

# Define standard_operation_mean by dividing mean_time_taken_operation by OpHr(PO)
df['standard_operation_mean'] = df['mean_time_taken_operation'] / df['OprHrs']

# Identify jobs with high delays
df['normalized_time_taken'] = df['time_taken'] / df['OprHrs']
df['delay_operation'] = df['normalized_time_taken'] > 1.05 * df['standard_operation_mean']
df['delay_machine'] = df['time_taken'] > 1.05 * df['mean_time_taken_machine']

# Display the first few rows to check the data
print(df.head(5))

from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense
from sklearn.metrics import r2_score
from sklearn.metrics import mean_absolute_error, mean_squared_error

"""
# Prepare data for modeling
features = ['Operation_Text', 'M/c_Description', 'normalized_time_taken', 'standard_operation_mean']
df['Operation_Text'] = df['Operation_Text'].astype('category').cat.codes
df['M/c_Description'] = df['M/c_Description'].astype('category').cat.codes
"""
# Prepare data for modeling
df['Operation Text Code'] = df['Operation_Text'].astype('category').cat.codes
df['M/c Description Code'] = df['M/c_Description'].astype('category').cat.codes
features = ['Operation Text Code', 'M/c Description Code', 'normalized_time_taken', 'standard_operation_mean']
X = df[features]
y = df['time_taken']/ df['OprHrs']

# Split the data into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Standardize the features
scaler = StandardScaler()
X_train = scaler.fit_transform(X_train)
X_test = scaler.transform(X_test)

# Build the ANN model
model_ann = Sequential()
model_ann.add(Dense(units=64, activation='relu', input_dim=X_train.shape[1]))
model_ann.add(Dense(units=32, activation='relu'))
model_ann.add(Dense(units=1))

# Compile the model
model_ann.compile(optimizer='adam', loss='mean_squared_error')

# Train the model
model_ann.fit(X_train, y_train, epochs=100, batch_size=32, validation_split=0.2, verbose=2)

# Predict and evaluate the model
y_pred_ann = model_ann.predict(X_test)
mae_ann = mean_absolute_error(y_test, y_pred_ann)
mse_ann = mean_squared_error(y_test, y_pred_ann)
rmse_ann = np.sqrt(mse_ann)
r2_ann = r2_score(y_test, y_pred_ann)

print(f'ANN - Mean Absolute Error: {mae_ann}')
print(f'ANN - Mean Squared Error: {mse_ann}')
print(f'ANN - Root Mean Squared Error: {rmse_ann}')
print(f'ANN - R-squared: {r2_ann:.4f}')

# Create the necessary mappings again
operation_text_map = df[['Operation_Text', 'Operation Text Code']].drop_duplicates().set_index('Operation_Text')['Operation Text Code'].to_dict()
machine_description_map = df[['M/c_Description', 'M/c Description Code']].drop_duplicates().set_index('M/c_Description')['M/c Description Code'].to_dict()

# Create a dictionary for standard operation mean times
operation_mean_time_dict = df.set_index('Operation_Text')['standard_operation_mean'].to_dict()
operation_machine_mean_time_dict = df.set_index('Operation_Text')['mean_time_taken_operation'].to_dict()

# Define the function to predict delay and estimate time of delay
def predict_delay(operation_text, machine_description):
    # Convert inputs to string and strip leading/trailing whitespaces
    operation_text = str(operation_text).strip()
    machine_description = str(machine_description).strip()

    # Handle cases where operation_text or machine_description are not in the mapping
    if operation_text not in operation_text_map:
        print(f"Warning: Operation '{operation_text}' not found in training data. Prediction may be inaccurate.")
        return None, None

    if machine_description not in machine_description_map:
        print(f"Warning: Machine '{machine_description}' not found in training data. Prediction may be inaccurate.")
        return None, None

    # Convert categorical features to numerical codes
    operation_code = operation_text_map[operation_text]
    machine_code = machine_description_map[machine_description]

    # Prepare the feature array
    feature_array = np.array([[operation_code, machine_code, 0, 0]])  # Placeholder for normalized_time_taken and standard_operation_mean

    # Standardize the feature array
    feature_array_standardized = scaler.transform(feature_array)

    # Predict the normalized time taken using the ANN model
    normalized_time_taken_pred = model_ann.predict(feature_array_standardized)[0][0]

    # Calculate the actual time taken based on the operation's standard operation mean
    standard_operation_mean = operation_mean_time_dict.get(operation_text, None)
    if standard_operation_mean is None:
        print(f"Warning: Standard operation mean for '{operation_text}' not found. Cannot estimate time.")
        return None, None

    time_taken_pred = operation_machine_mean_time_dict[operation_text]

    # Calculate the delay based on 1.05 threshold
    delay_operation = normalized_time_taken_pred > 1.05 * standard_operation_mean

    # Return the results
    is_delay = 'yes' if delay_operation else 'no'
    time_required = f"{time_taken_pred:.2f} hours"
    return is_delay, time_required

# Example usage
print(predict_delay('ROUGH TURNING', 'EB-1B-VBOR'))
print(predict_delay('MACHINING', 'EB-1B-VBOR'))

print(predict_delay('SLOTTING KEYWAY', 'LB-26B-SLOT'))


from fastapi import FastAPI
from pydantic import BaseModel
import pickle
import json
import uvicorn
from pyngrok import ngrok
from fastapi.middleware.cors import CORSMiddleware
import nest_asyncio

app = FastAPI()

origins = ["*"]

app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Define the request body model
class ModelInput(BaseModel):
    Operation: str
    Machine: str

@app.post('/delay')
def predict_delay_api(input_parameters: ModelInput):
    # Extract input data
    opr = input_parameters.Operation
    mach = input_parameters.Machine

    # Get the prediction
    is_delay, time_required = predict_delay(opr, mach)

    # Check if prediction was successful
    if is_delay is None or time_required is None:
        return {
            'isDelay': 'error',
            'time_required': 'Prediction failed due to unknown operation or machine description.'
        }

    # Return the response in the desired format
    return {
        'isDelay': is_delay,
        'time_required': time_required
    }

# Apply the asyncio event loop policy
nest_asyncio.apply()

# Run the FastAPI app
uvicorn.run(app, port=8000)